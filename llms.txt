Duality Framework v1.0: Implementation Reference
Status: Implementation Ready Language: Rust (Framework Core), TypeScript (Compiler Logic)
1. The Reactivity Engine (duality_core::reactivity)
Requirement: Glitch-free, fine-grained, thread-safe signals. Philosophy: Push-pull hybrid. Updates are pushed to a dirty queue, values are pulled lazily.
1.1 The Signal Primitive
use std::cell::{RefCell, Ref};
use std::rc::{Rc, Weak};

// The Runtime Context
thread_local! {
   static OBSERVER: RefCell<Option<Weak<dyn AnyEffect>>> = RefCell::new(None);
   static BATCH_QUEUE: RefCell<Vec<Rc<dyn AnyEffect>>> = RefCell::new(Vec::new());
}

pub struct Signal<T> {
   value: RefCell<T>,
   subscribers: RefCell<Vec<Weak<dyn AnyEffect>>>,
}

impl<T> Signal<T> {
   pub fn new(val: T) -> Rc<Self> {
       Rc::new(Self {
           value: RefCell::new(val),
           subscribers: RefCell::new(Vec::new()),
       })
   }

   pub fn get(&self) -> Ref<T> {
       // 1. Dependency Tracking
       OBSERVER.with(|ctx| {
           if let Some(observer) = ctx.borrow().as_ref() {
               self.subscribers.borrow_mut().push(observer.clone());
           }
       });
       self.value.borrow()
   }

   pub fn set(&self, new_val: T) {
       if *self.value.borrow() == new_val { return; }
       
       *self.value.borrow_mut() = new_val;
       
       // 2. Notification (Push to Batch)
       let subs = self.subscribers.borrow();
       for sub in subs.iter() {
           if let Some(effect) = sub.upgrade() {
               effect.mark_dirty();
           }
       }
       
       // 3. Trigger Graph Propagation
       schedule_microtask();
   }
}

1.2 The Effect (Computation)
pub struct Effect {
   func: Box<dyn Fn()>,
   cleanups: RefCell<Vec<Box<dyn Fn()>>>,
}

impl Effect {
   pub fn new<F: Fn() + 'static>(f: F) {
       let effect = Rc::new(Self { 
           func: Box::new(f),
           cleanups: RefCell::new(Vec::new()) 
       });
       effect.run();
   }

   fn run(self: Rc<Self>) {
       // 1. Cleanup previous run
       for cleanup in self.cleanups.borrow_mut().drain(..) {
           cleanup();
       }

       // 2. Set generic Context for tracking
       OBSERVER.with(|ctx| {
           *ctx.borrow_mut() = Some(Rc::downgrade(&self));
           (self.func)(); // Run user code
           *ctx.borrow_mut() = None;
       });
   }
}

2. Templating & Compiler Logic (duac)
Requirement: TSX to WasmGC with Static Analysis. Philosophy: 1 TSX Component = 1 Wasm Struct + 1 Static HTML Template.
2.1 Compiler Output Pseudocode (What duac generates)
Input (Counter.tsx):
export default function Counter() {
   const count = new Signal(0);
   return (
       <div class="box">
           <span>Count: {count.get()}</span>
           <button onclick={() => count.set(c => c + 1)}>+</button>
       </div>
   )
}

Generated Rust (target/wasm32-unknown-unknown):
// 1. Static HTML extracted
const TEMPLATE_ID: &str = "duality_tpl_1";
const TEMPLATE_HTML: &str = "<div class='box'><span>Count: </span><button>+</button></div>";

struct CounterComponent {
   count: Rc<Signal<i32>>,
   root: ExternRef, // DOM Node Reference
}

impl Component for CounterComponent {
   fn mount(&self, parent: ExternRef) {
       // 1. Clone Template (Fastest DOM creation)
       let fragment = internal::clone_template(TEMPLATE_ID);
       
       // 2. Walk the DOM (Indices calculated at compile time)
       // Path: div (0) -> span (0) -> text_node (1)
       let text_node = internal::walk_dom(&fragment, &[0, 0, 1]);
       let btn = internal::walk_dom(&fragment, &[0, 1]);

       // 3. Bind Reactivity (Fine-Grained)
       // Compiler hoisting: moves 'count' into closure
       let c_clone = self.count.clone();
       Effect::new(move || {
           // Direct DOM manipulation via WasmGC
           text_node.set_text_content(&c_clone.get().to_string());
       });

       // 4. Bind Events
       let c_clone_2 = self.count.clone();
       internal::add_event_listener(btn, "click", move || {
           let current = *c_clone_2.get();
           c_clone_2.set(current + 1);
       });

       parent.append_child(fragment);
   }
}

3. Control Flow & DOM Diffing (duality_core::dom)
Requirement: Keyed Lists (<For>) and Conditionals (<Show>). Philosophy: No VDOM. Direct DOM moves based on data diffs.
3.1 The <For> Reconciler (Levenshtein Strategy)
pub fn reconcile_list<T, K>(
   parent: &ExternRef, 
   anchor: &ExternRef,
   old_list: &[T], 
   new_list: &[T],
   key_fn: fn(&T) -> K
) where K: PartialEq {
   // 1. Fast Path: Empty to Full
   if old_list.is_empty() {
       for item in new_list {
           let node = render(item);
           parent.insert_before(node, anchor);
       }
       return;
   }

   // 2. Fast Path: Full to Empty
   if new_list.is_empty() {
       // Efficient range removal
       let range = parent.get_range(old_list[0].node, old_list.last().node);
       range.delete_contents();
       return;
   }

   // 3. Wasm-Optimized Diff (Longest Common Subsequence)
   // We calculate the minimal number of DOM moves (insertBefore)
   let moves = calculate_lcs_moves(old_list, new_list, key_fn);
   
   for op in moves {
       match op {
           Op::Create(item) => parent.insert_before(render(item), anchor),
           Op::Move(item, ref_node) => parent.insert_before(item.node, ref_node),
           Op::Remove(item) => item.node.remove(),
       }
   }
}

4. The Component System (duality_core::component)
Requirement: Web Component Output with Shadow DOM.
4.1 The Web Component Shim (JS Side)
This tiny JS file bridges the browser to Wasm.
class DualityComponent extends HTMLElement {
   constructor() {
       super();
       this._wasm_instance = null;
   }

   connectedCallback() {
       const id = this.getAttribute('data-id') || crypto.randomUUID();
       // Call Wasm export
       window.duality.exports.mount_component(
           this.tagName.toLowerCase(), 
           id, 
           this // Pass 'this' as ExternRef
       );
   }

   disconnectedCallback() {
       window.duality.exports.unmount_component(this.id);
   }

   // Attributes -> Signals
   static get observedAttributes() { return window.duality.manifest[this.tagName]; }
   attributeChangedCallback(name, oldVal, newVal) {
       window.duality.exports.update_prop(this.id, name, newVal);
   }
}
customElements.define('ion-app', DualityComponent);

4.2 The Constructable Stylesheet Engine
pub fn apply_styles(shadow_root: &ExternRef, css: &str) {
   // Cache styles in a Wasm-global Map
   // Only parse CSS once per component type, not per instance
   let sheet = STYLE_CACHE.get_or_insert(css, || {
       let s = CSSStyleSheet::new();
       s.replace_sync(css);
       s
   });
   
   // Zero-copy adoption
   shadow_root.set_adopted_style_sheets(&[sheet]);
}

5. Router & Data (duality_std)
Requirement: File-system routing, RPC, View Transitions.
5.1 The RPC Macro (#[duality::server])
Used in src/server/actions.rs.
#[duality::server]
pub async fn update_user(id: String, data: UserData) -> Result<User, Error> {
   // 1. Auth Check (Implicit Middleware)
   let user = ctx.get_user()?;
   
   // 2. DB logic
   let res = db.users.update(id, data).await?;
   
   Ok(res)
}

Expanded Client Code (Generated by macro):
// Generated WASM Client
pub async fn update_user(id: String, data: UserData) -> Result<User, Error> {
   let body = bincode::serialize(&(id, data));
   
   let resp = fetch("/_rpc/update_user", RequestInit {
       method: "POST",
       body: Some(body),
       headers: {
           "Content-Type": "application/octet-stream",
           "X-CSRF-Token": get_csrf_token() // Security req
       }
   }).await?;

   let bytes = resp.array_buffer().await?;
   bincode::deserialize(&bytes)
}

5.2 View Transitions Integration
pub fn navigate(to: &str) {
   if document::start_view_transition_supported() {
       document::start_view_transition(move || {
           // This runs inside the transition promise
           // DOM updates here are snapshotting by the browser
           ROUTER.set_path(to);
           tick(); // Flush signals
       });
   } else {
       ROUTER.set_path(to);
   }
}

6. Observability & Security (duality_core::guard)
Requirement: CSP, Panics, Telemetry.
6.1 Panic Hook (Error Boundary)
pub fn init_panic_hook() {
   std::panic::set_hook(Box::new(|info| {
       // 1. Console Error
       console_error!("Duality Wasm Panic: {:?}", info);

       // 2. Find nearest ErrorBoundary in Component Tree
       if let Some(boundary) = find_nearest_boundary() {
           boundary.set_error(info.to_string());
       }

       // 3. Telemetry Dispatch (if configured)
       if let Some(telemetry) = get_telemetry() {
            telemetry.send_crash_report(info);
       }
   }));
}

6.2 CSP & CSRF
* CSP: The system relies on wasm-unsafe-eval (required for Wasm currently) but strictly forbids unsafe-inline for scripts.
* CSRF: The duality_server middleware automatically injects a __Host-csrf cookie. The Wasm runtime reads this cookie via document.cookie (if HTTP-only is false) or expects it in the HTML head meta tag for injection into RPC headers.
7. Server-Side Rendering (duality_ssr)
Requirement: Binary Resumability.
7.1 Snapshot Engine
pub fn render_to_stream(app: App) -> impl Stream<Item = Bytes> {
   // 1. Boot Wasm instance on Server
   let mut instance = WasmInstance::new(app);
   
   // 2. Run App Logic (Wait for Suspense)
   instance.run_until_settled().await;

   // 3. Extract DSD (Declarative Shadow DOM)
   let html_head = instance.get_document_head();
   let html_body = instance.get_shadow_roots_as_dsd();

   // 4. Capture Heap
   let memory_snapshot = instance.export_memory();
   let compressed_mem = lz4::compress(&memory_snapshot);

   // 5. Stream
   stream! {
       yield html_head;
       yield html_body;
       yield format!("<script type='application/wasm-snapshot'>{}</script>", base64(compressed_mem));
       yield "<script src='/duality.js'></script>";
   }
}

7.2 Client Hydration (Wake Up)
// On Client Boot
fn main() {
   // 1. Locate Snapshot
   let snapshot_script = document.query_selector("script[type='application/wasm-snapshot']");
   let bytes = base64_decode(snapshot_script.text_content());

   // 2. Instantiate Wasm with imported memory
   let memory = WebAssembly::Memory::new({ initial: bytes.len() });
   memory.fill(bytes); // Restore state

   // 3. Resume
   // No "Hydration" pass needed. The variables in memory are already set.
   // We just re-attach event listeners to existing DOM nodes.
   attach_event_delegates();
}

8. Internationalization (duac::i18n)
Requirement: Compile-time injection.
8.1 Macro Usage
// usage
let greeting = t!("welcome.hello", name = user.name);

8.2 Compiler Transformation
The compiler reads locales/en.json and locales/fr.json. It generates conditional compilation logic:
// Generated Code
#[cfg(feature = "locale_en")]
let greeting = format!("Hello, {}", user.name);

#[cfg(feature = "locale_fr")]
let greeting = format!("Bonjour, {}", user.name);

Result: Each locale build contains only its strings. Zero runtime lookup table overhead.
9. Tooling (dlty CLI)
Requirement: Orchestration.
9.1 Development Server (HMR Logic)
The dlty dev command runs a Rust WebSocket server.
// HMR Server Logic
fn watch_loop() {
   let mut watcher = notify::recommended_watcher(|res| {
       match res {
           Ok(event) => {
               // 1. Recompile ONLY the changed file to a JS Module (JIT Proxy)
               let js_module = compile_jit_proxy(event.path);
               
               // 2. Push update to browser via WebSocket
               ws_send(HmrUpdate {
                   file: event.path,
                   code: js_module
               });
           }
           Err(e) => eprintln!("Watch error: {:?}", e),
       }
   });
}